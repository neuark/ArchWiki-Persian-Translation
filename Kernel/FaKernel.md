کرنل های با پشتیبانی رسمی
بر اساس ویکی پدیا:

کرنل لینوکس یک کرنل سیستم عامل کامپیوتر یکپارچه متن باز یونیکس مانند است.
آرچ لینوکس بر پایه کرنل لینوکس است. کرنل های لینوکس جایگزین مختلفی برای آرچ لینوکس علاوه بر آخرین کرنل پایدار موجود است. این مقاله فهرستی از برخی از گزینه های موجود در مخازن را با شرح مختصری از هر یک  است . همچنین توصیفی از پچ ها وجود دارد که میتوانند روی کرنل سیستم اعمال شوند. مقاله با یک مرور کلی از کامپایل کرنل سفارشی با پیوندهایی به روشهای مختلف به پایان میرسد.

بسته های کرنل در  مسیر /usr/lib/modules/ نصب می شوند و سپس  برای کپی کردن تصویر (image) اجرایی vmlinuz به /boot/ استفاده میشوند. هنگام نصب یک کرنل متفاوت یا تعویض بین چندین کرنل، باید بوت لودر خود را تنظیم کنید تا تغییرات را اعمال کند. برای انتقال کرنل به یک نسخه قدیمی تر، ببینید

پایدار — کرنل پیش فرظ لینوکس و ماژول ها، با چند پچ اعمال شده است.
یک کرنل لینوکس متمرکز بر امنیت که مجموعه ای از وصله های سخت افزاری را برای کاهش سوء استفاده های کرنل و فضای کاربر اعمال می کند. همچنین ویژگی های سخت افزاری کرنل بالادست بیشتری را نسبت به لینوکس امکان پذیر می کند.
پشتیبانی طولانی مدته (LTS) کرنل لینوکس و ماژول ها. مفید در هنگام استفاده از ماژول های خارج از درخت (out-of-tree) که ممکن است انتشار به موقع سازگار با آخرین کرنل پایدار را منتشر نمی کند.

توسط گروه کوچکی از توسعه دهندگان کرنل به رهبری اینگو مولنار نگهداری میشود. این پچ اجازه می دهد تا تقریبا تمام کرنل پیش گرفته شود، به استثنای چند منطقه بسیار کوچک از کد ("raw_spinlock مناطق بحرانی"). این کار با جایگزینی اکثر اسپینل های کرنل با موتیکس هایی که از وراثت اولویت پشتیبانی می کنند و همچنین حرکت دادن تمام وقفه ها و وقفه های نرم افزاری به موضوعات کرنل انجام می شود.


پشتیبانی از کرنل Real-Time در لینوکس 6.12 اضافه شد
نتیجه تلاش مشترک هکرهای کرنل برای ارائه بهترین کرنل لینوکس ممکن برای سیستمهای روزمره.


روش های زیر را می توان برای کامپایل کرنل خود استفاده کرد:

شامل دانلود دستی یک تاربال سورس، و کامپایل در دایرکتوری خانه خود را به عنوان یک کاربر عادی.
##### warning
* استفاده از کرنل های شخصی سازی شده (کاستوم) ممکن است باعث ایجاد انواع مشکلات ثبات و قابلیت اطمینان شود ، از جمله از دست دادن داده ها شود. پشتیبان گیری به شدت توصیه می شود.

* آرچ لینوکس فقط به صورت رسمی از کرنل های رسمی پشتیبانی میکند. هنگام استفاده از یک کرنل متفاوت، لطفا در درخواست های پشتیبانی ذکر کنید.

##### note
* بهترین راه برای افزایش سرعت سیستم شما این است که ابتدا  پیکربندی کرنل خود را به معماری و نوع پردازنده خود متناسب کنید.

* شما می توانید اندازه کرنل خود را (و در نتیجه زمان ساخت) را با عدم پشتیبانی از چیزهایی که ندارید یا استفاده نمی کنید، کاهش دهید. به عنوان مثال پشتیبانی از چیزهایی مانند بلوتوث، video4linux، اترنت 1000 مگابیت و غیره.

* فایل پیکربندی برای بسته کرنل ارچ فایل بسته سورس ارچ هستند (برای مثال 2 لینک شده برای لینوکس ). فایل کانفیگه کرنلی که در حال حاضر در حال اجرای ان هستید احتمال دارد که در فایل سیستم شما در /proc/config.gz موجود باشد اگر گزینه کرنل CONFIG_IKCONFIG_PROC روشن باشد .

### 1.1 کرنل های kernel.org

* Git - کرنل لینوکس و ماژول های ساخته شده با استفاده از منابع مخزن گیت  لایتس توروالت.
* Mainline — کرنل هایی که در آن تمام ویژگی های جدید معرفی می شوند، هر 2-3 ماه منتشر می شوند.
* Next — کرنل هایی بسیار به روز با ویژگیهایی قرار است به انتشار کرنل mainline بعدی اضافه شوند. 
* DRM — کرنل لونکس با اخرین به روز رسانی هایی درایور کارت گرافیک
* Longterm — پشتیبانی طولانی مدت (LTS) کرنل لینوکس و ماژول هایش.

### کرنل های غیر رسمی 
* Clear — پچ هایی از پروژه لینوکس clear اینتل. ارائه بهینه سازی عملکرد و امنیت.
* pf-kernel — تعداد انگشت شماری از ویژگی های جذاب را فراهم می کند که در کرنل mineline ادغام نشده است. توسط یک مهندس کرنل مینتین می شود. اگر پورت برای پچ گنجانده شده برای هسته های جدید به طور رسمی منتشر نشود، پچ پچ پورت های پچ را به هسته های جدید فراهم می کند و پشتیبانی می کند. برجسته ترین تکه های لینوکس-PF در حال حاضر UKSM، DDCCI، v4l2loopback و BBRv3 هستند.
* Project C — کرنل با مجموعه پچ های پروژه C آلفرد چن (برنامه های BMQ و PDS).
* Nitrous — کرنل لینوکس اصلاح شده بهینه شده برای اسکای لیک ( Skylake ) و جدیدتر.
*  tkg — یک سیستم ساخت کرنل بسیار قابل تنظیم است که مجموعه ای از تکه ها و ترفندها را با هدف عملکرد بهتر دسک تاپ و بازی فراهم می کند. توسط اتین جوینی مینتین میشود. در میان پچ های دیگر، برنامه های مختلف CPU را ارائه می دهد: CFS، پروژه C PDS، پروژه C BMQ، MuQSS و CacULE.
* VFIO — کرنل لینوکس و چند پچ نوشته شده توسط الکس ویلیامسون (acs override و i915) برای فعال کردن توانایی انجام PCI Passtrough با KVM در برخی از سیستم ها .
* XanMod — با هدف استفاده کامل از ورک استیشن ها با بازدهی ( پرفورمنس ) بالا، دسکتاپ های بازی، مراکز رسانه ای و دیگران و ساخته شده برای ارائه یک تجربه دسکتاپ بی نقص، سریع و نرم. این کرنل از زمانبند BFQ I/O، کنترل ازدحام TCP BBRv3، پشتیبانی از مجموعه دستورالعمل پیشرفته x86_64، بخصوص پچهای Clear لینوکس و سایر تغییرات پیش فرض استفاده می کند.
* linux-cachyos — کرنل لینوکس SCHED-EXT + BORE + Cachy sauce توسط CachyOS با پچ های دیگر و بهبود کرنل و ماژول ها.

بسیاری از این کرنل های غیر رسمی حاوی ویژگی هایی هستند که باید به صورت دستی فعال شوند. سعی کنید مستندات را در پچ های خود بخوانید (بسیاری از آنها در حال حاضر شامل تغییرات در دایرکتوری /Documentation در منبع کرنل هستند) یا نام پچ را در وب جستجو کنید.

##### پنیک کرنل

پنیک کرنل زمانی رخ میدهد که هسته لینوکس وارد حالت شکست غیرقابل بازیابی شود. این حالت به طور معمول از درایورهای سخت افزاری ناشی می شود که منجر به قفل شدن دستگاه، عدم پاسخ و نیاز به راه اندازی مجدد مسشود .


> Note
>> کرنل پنیک ها گاهی اوقات به عنوان oops یا kernel oops نامیده می شود. در حالی که هر دو حالت پنیک و oops به عنوان نتیجه یک حالت عدم موفقیت رخ میدهد، opps از این نظر عمومی تر است که لزوماً منجر به قفل شدن سیستم نمی شود: گاهی اوقات کرنل میتواند با به پایان دادن یک کار متخلف و انجام کار، از  حالت opps بازیابی کند.

> Tip
>> متغیر کرنل oops=panic در فرایند بوت قرار دهید یا برای اجبار یک oops قابل بازیابی به ایجاد یک کرنل پنیک در /proc/sys/kernel/panic_on_oops عدد 1 را بنویسید. این قابل توصیه است اگر شما در مورد احتمال کمی از بی ثباتی سیستم ناشی از بازیابی OOPS نگران هستید که ممکن است ارورهای آینده را دشوار برای تشخیص کند .
##### بررسی پیام کرنل پنیک

اگر یک کرنل پنیک در اوایل فرآیند بوت رخ دهد، شما ممکن است یک پیام در کنسول حاوی Kernel panic - not syncing اما هنگامی که systemd در حال اجرا است، پیام های هسته به طور معمول دریافت و نوشته شده به ورود به سیستم. با این حال، هنگامی که یک کرنل پنیک رخ میدهد، خروجی پیام تشخیصی توسط کرنل تقریباً هرگز به فایل لاگ بر روی دیسک نوشته نمیشود زیرا ماشین قبل از این که system-journald شانسی برای نوشتن لاگ داشته باشد، قفل میشود.

##### کد QR در صفحه ای ابی 
از آ لینوکس 6.10 (برای drm_panic) ، هسته پنیک را به عنوان یک کد QR (به طور پیش فرض) در یک صفحه آبی نمایش می دهد. stack ردیابی  در URL داده شده توسط کد QR قابل مشاهده است. URL شامل اطلاعات مختلف و ردیابی پشته فشرده شده توسط gzip و کد گذاری شده در قطعه URL است که به سرور منتقل نمی شود (در سمت کاربر پردازش می شود). 
یک  مثال پنیک را می توان با یک تصویر در یک پست مروم مشاهده کرد.

شما می توانید با استفاده از متغیر panic_screen=kmsg به ماژول کرنل drm به رفتار قدیمی بازگردید.(یا drm.panic_screen=kmsg به عنوان متغیر کرنل) برای نمایش ردیابی پشته در یک کنسول.

##### روش کنسول 
روش سبک "قدیمی" برای مشاهده کرش در کنسول درحالی که اتفاق می افتد هنوز در دسترس است (بدون توسل به راه اندازی یک crashkernel kdump). بوت با متغیرهای کرنل زیر و تلاش برای بازتولید پنیک در tty1:
> systemd.journald.forward_to_console=1 console=tty1

> Tip
>> در صورتی که پیام پنیک  بیش از حد سریع برای بررسی حرکت می کند، سعی کنید متغیر کرنل pause_on_oops=seconds را در بوت امتحان کنید.

##### سناریو مثال : ماژول بد
میتوان به بهترین نحو حدس زد که چه ساب سیستم یا ماژول با استفاده از اطلاعات موجود در پیام تشخیصی باعث ایجاد کرنل میشود. در این سناریو، ما در هنگام بوت شدن یک پنیک بر روی برخی از ماشین های خیالی داریم. به خطوط برجسته شده به صورت پررنگ توجه کنید:

kernel: BUG: unable to handle kernel NULL pointer dereference at (null) 1
kernel: IP: fw_core_init+0x18/0x1000 [firewire_core] 2
kernel: PGD 718d00067
kernel: P4D 718d00067
kernel: PUD 7b3611067
kernel: PMD 0
kernel:
kernel: Oops: 0002 [#1] PREEMPT SMP
kernel: Modules linked in: firewire_core(+) crc_itu_t cfg80211 rfkill ipt_REJECT nf_reject_ipv4 nf_log_ipv4 nf_log_common xt_LOG nf_conntrack_ipv4 ... 3
kernel: CPU: 6 PID: 1438 Comm: modprobe Tainted: P           O    4.13.3-1-ARCH #1
kernel: Hardware name: Gigabyte Technology Co., Ltd. H97-D3H/H97-D3H-CF, BIOS F5 06/26/2014
kernel: task: ffff9c667abd9e00 task.stack: ffffb53b8db34000
kernel: RIP: 0010:fw_core_init+0x18/0x1000 [firewire_core]
kernel: RSP: 0018:ffffb53b8db37c68 EFLAGS: 00010246
kernel: RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
kernel: RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffffc16d3af4
kernel: RBP: ffffb53b8db37c70 R08: 0000000000000000 R09: ffffffffae113e95
kernel: R10: ffffe93edfdb9680 R11: 0000000000000000 R12: ffffffffc16d9000
kernel: R13: ffff9c6729bf8f60 R14: ffffffffc16d5710 R15: ffff9c6736e55840
kernel: FS:  00007f301fc80b80(0000) GS:ffff9c675dd80000(0000) knlGS:0000000000000000
kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
kernel: CR2: 0000000000000000 CR3: 00000007c6456000 CR4: 00000000001406e0
kernel: Call Trace:
kernel:  do_one_initcall+0x50/0x190 4
kernel:  ? do_init_module+0x27/0x1f2
kernel:  do_init_module+0x5f/0x1f2
kernel:  load_module+0x23f3/0x2be0
kernel:  SYSC_init_module+0x16b/0x1a0
kernel:  ? SYSC_init_module+0x16b/0x1a0
kernel:  SyS_init_module+0xe/0x10
kernel:  entry_SYSCALL_64_fastpath+0x1a/0xa5
kernel: RIP: 0033:0x7f301f3a2a0a
kernel: RSP: 002b:00007ffcabbd1998 EFLAGS: 00000246 ORIG_RAX: 00000000000000af
kernel: RAX: ffffffffffffffda RBX: 0000000000c85a48 RCX: 00007f301f3a2a0a
kernel: RDX: 000000000041aada RSI: 000000000001a738 RDI: 00007f301e7eb010
kernel: RBP: 0000000000c8a520 R08: 0000000000000001 R09: 0000000000000085
kernel: R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000c79208
kernel: R13: 0000000000c8b4d8 R14: 00007f301e7fffff R15: 0000000000000030
kernel: Code: <c7> 04 25 00 00 00 00 01 00 00 00 bb f4 ff ff ff e8 73 43 9c ec 48
kernel: RIP: fw_core_init+0x18/0x1000 [firewire_core] RSP: ffffb53b8db37c68
kernel: CR2: 0000000000000000
kernel: ---[ end trace 71f4306ea1238f17 ]---
kernel: Kernel panic - not syncing: Fatal exception 5
kernel: Kernel Offset: 0x80000000 from 0xffffffff810000000 (relocation range: 0xffffffff800000000-0xfffffffffbffffffff
kernel: ---[ end Kernel panic - not syncing: Fatal exception

* نوع خطایی را که باعث پنیک شده است نشان می دهد. در این مورد  اشکال برنامه نویسی بود.
* نشان می دهد که پکین در یک تابع به نام fw_core_init در ماژول firewire_core اتفاق افتاده است.
* نشان می دهد که firewire_core آخرین ماژول بارگذاری شده بوده است.
* نشان می دهد که تابعی که function fw_core_init نامیده می شود do_one_initcall بوده است.
* نشان می دهد که این پیام OOPS در واقع یک کرنل پنیکی است و سیستم در حال حاضر قفل شده است.


